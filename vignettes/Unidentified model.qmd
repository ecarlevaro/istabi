---
title: "Unidentified case"
author: "Emi Carlevaro"
date: today
date-meta: 14/01/2026
editor: 
  mode: source
format: 
  html:
    code-fold: true
    code-tools: true
    self-contained: true
    page-layout: full
    toc: true
params:
  IDSAMPLE: ""
  NCORES: 4
  LOCALSEARCH: 'true'
---

## INIT

```{r, eval=FALSE}
#required packages to make a package
pacman::p_load(devtools, roxygen2, testthat)
#dependecies
#pacman::p_load(tidyverse, data.table, DT, plotly, gridExtra, latex2exp, here, logr, future.apply, furrr)
#pacman::p_load(dplyr,parallel,sandwich,here,future,logr,profvis,lobstr,parallel)
#https://ourcodingclub.github.io/tutorials/writing-r-package/
#create_package
#https://combine-australia.github.io/r-pkg-dev/functions.html
#load_all()
#run these two lines and then library(GridMaker) in normal rstudio to install package
# load_all loads a package. It roughly simulates what happens when a package is installed and loaded with library().
devtools::load_all()

devtools::install()
```

```{r}
library(vars)
library(tidyverse)
library(iStabi)
```


```{r}
sam <- iStabi::data_sim_biVAR
```


## THE MODEL

True parameters are

$$ 
\begin{align}
y_{1,t} &= \textcolor{blue}{\beta} \,\, y_{2,t} + 0.5 y_{1, t-1} + 0.2 y_{2, t-1} + w_{1, t} \\
y_{2,t} &= \textcolor{blue}{\alpha} \,\, y_{1,t} + 0.1 y_{1, t-1} + 0.4 y_{2, t-1} + w_{2, t} 
\end{align}
$$

$$ 
\begin{bmatrix}1 & -0.15 \\ 0.75 & 1\end{bmatrix} y_t = \begin{bmatrix}0.5 & 0.2 \\ 0.1 & 0.4\end{bmatrix} y_{t-1} +  w_t
$$

with $\beta = 0.15$ and $\alpha = -0.75$.

## ESTIMATION VAR

```{r}
varModel <- VAR(cbind('i' = sam$y1, 's' = sam$y2), p = 1, type = "const")
Res = residuals(varModel)

```

```{r}
# Use for computing the moment function
Omega <- cbind('ii' = Res[, 'i']*Res[, 'i'], 'is' = Res[, 'i']*Res[, 's'],
               'ss' = Res[, 's']*Res[, 's'])

Y <- cbind( 'omega_ii' = Omega[, 'ii'], 'omega_ss' = Omega[,'ss'], 'omega_is' = Omega[,'is'] )

# Compute the moment function at each t. 
# INPUT: a named vector with values for the structural parameters
# OUTPUT: a TxG matrix where each row corresponds to the value of the moment function on that obseration (date)
# an each column the value fot ehfat moment equation
GET_MOM_VALUES <- function(t0, ...) {
  list2env(as.list(t0),envir = environment())
  
  #Y <- cbind( 'omega_ii' = Res[,'i']^2, 'omega_ss' = Res[,'s']^2, 'omega_is' = Res[,'i'] * Res[,'s'] )
  
  #Y %*% c(-theta0['alpha'],
  #        -theta0['beta'],
  #        1 + theta0['alpha'] * theta0['beta'])
  
  #fT 
  as.matrix(-alpha*Omega[, 'ii'] - beta*Omega[, 'ss'] + (1+alpha*beta) * (Omega[, 'is']))
  # fT - lambda
  
  #matrix(fT - mean(fT),
  #       ncol = 1) # (T-varLeng) X 1
  
} 
```



```{r, eval=FALSE}
GET_B <- function(theta0) {
  c(-theta0['alpha'],
    -theta0['beta'],
    1 + theta0['alpha'] * theta0['beta'])
}


```

## SEARCH

### Search settings

```{r}
#### Search settings ----
NCORES = params$NCORES
STEPSPERCORE = 200
# Size of adjacent cells to explores is NCORES * STEPSPERCORE

# PARAMS_CFG a tibble where each row defines properties of the parameters in the name column
# stepSize: size of the step for each parameter. You can have different sizes (and precision) for each paramter.
# minVal and maxVal: Limits of the parameter space for each parameters. A list where each element defines the minimum and maximum for each parameter
# ORDER: the order of the parameter has to match the order in theta (as used by the get_b() fcn)
PARAMS_CFG <- tribble(~name,   ~iniVal, ~stepSize, ~minVal, ~maxVal,
                      'alpha',   0.3,    0.05,        -1,      1,
                       'beta',  -0.2,    0.05,        -1,       1) %>%
  mutate('N_TICKS' = ((maxVal-minVal)/stepSize)+1)

```

```{r}
NEQS = 1
MODELEQS <- list(list('Y' = Y,  'get_b'=NULL))
                 #'X'=X, 'Z'=Z))
NCORES = 4
# Level of condfidence of the S set. The closer to 1, the more robust the search is to local minima but it takes longer.
SPVALUE = 0.95
# R is NEQS*ncol(Z) where ncol(Z) is the number of instruments
# By default this matrix has to be automatically built depending on the dimensions of MODELEQS.
# The user can alternatively provide this matrix
R = 1
if (exists('Z', mode='numeric')) {
  R <-  rbind(
        cbind(matrix(1, nrow=ncol(Z), ncol=ncol(Z)))
  )
}

theta0 = PARAMS_CFG$iniVal
names(theta0) = PARAMS_CFG$name
head(GET_MOM_VALUES(theta0))

```

```{r}
verify_global(PARAMS_CFG, Y)
Times = NROW(Res) # time periods

generate_global(PARAMS_CFG,  SPVALUE)
```



### Global search grid

```{r}
gridLines <- build_lines(PARAMS_CFG, 'iniVal')

# paramsCfg <- PARAMS_CFG
# thisGridLines <- thisGridLines
# NEQS = 1
# psUnderNull = 1
Grid <- build_grid(PARAMS_CFG, gridLines)
```

Test
```{r}
theta0 = c('alpha' = -0.75, 'beta' = 0.15) # the true theta with the estimated (nuisance) parameter 0.378
comp_tests(theta0, VffLags = 1)
```

### Start search

```{r}
#logFileName <- 'log_file.txt'
#log_open(logFileName, logdir=FALSE, compact=TRUE)
#log_print(paste0("Local search? ", params$LOCALSEARCH))

#log_print(paste0("IniRows size (in bytes): ", lobstr::obj_size(IniRows)))
# rover_Perseverance will update the Grid in the Global env
#plan(multisession, workers=params$NCORES)

#log_print("Calling garbage collector before Stage2_rover_Perseverance")
expResult <- Stage2_rover_Perseverance(iniVal=PARAMS_CFG$iniVal, WTLags = 1, localSearch = FALSE) # updates the Grid by in place

```

```{r}
head(Grid)
```

```{r}
Grid[order(qLLStab)][1:10]
```



## PLOTTING





### Critical values
Critical values for $qLL-\tilde{S}$ for `r KZ` moment condition  from table VII Suplementary material, p3 Magnusson Mavroeidis (2014).

THe S-test follows a Chi-Square distribution with **`r KZMKX`** degrees of freedom (equatl to the number of moment conditions).

`Grid` has `r NROW(Grid)` rows.


The number of *fixed* identified parameters is **`r NFIXPARAMS`**.

The number of *estimated* parameters under the null is **`r NSIPARAMS`**.

```{r}

```


```{r CVs}
get_CVs <- function(pconf_min, pconf_max) {
  daiStabi::data_CVs
  CVs <- list('qLLStab'=NA, 'S'=NA, 'genS_qLL'=NA)

  PCONFS = c(pconf_min, pconf_max)
  
  CVs$qLLStab <- filter(iStabi::data_CVs$qLLStab, DG_F == KZ)
  CVs$genS_qLL <- filter(data_CVs$genS_qLL, 
                         MOMENT_CONDITIONS == KZ & STRONGLY_IDENTIFIED_PARAMETERS == NSIPARAMS)
  CVs$S <- tibble('P_CONF' = PCONFS,
                 'CUTOFF_TOP' = map_dbl(PCONFS, ~qchisq(.x, KZMKX)))
  
  CVs
}
#CV$S <- tibble('SIG' = c(0.1, 0.05, 0.01, 0),
#               'VALUE' = c(0, qchisq(.9, KZMKX), 
#                           qchisq(.95, KZMKX), 
#                           qchisq(.99, KZMKX)))

CVs <- get_CVs()
```

Critical values are:

::: {.panel-tabset}

### S
```{r}
CVs$S
```

### qLLStab
```{r}
CVs$qLLStab
```

### genS_qLL
```{r}
CVs$genS_qLL
```

:::


### Data for plotting

```{r}
Sdf =  2
Grid[!is.na(qLLStab), 'qLLStab_sigAt' := CVs$sig[ findInterval(qLLStab, CV$value,left.open=TRUE) ],]
pExplored <- filter(Grid, !if_all(.fns=is.na)) %>%
  # findInterval: the second vector gives the FLOOR value for each interval
  mutate(., 
         'qLLStab_sigAt' = CV$sig[ findInterval(qLLStab, CV$value,left.open=TRUE) ],
         'S_pval' = round(1-pchisq(S, df=Sdf), digits=2),
         'pointSize' = 0, 
         'inQllSet' = if_else(qLLStab_sigAt>=0.10, 1, 0))
# This should be TRUE (the qll value is for 3 instruments)
NROW(filter(pExplored, qLLStab<=23.51)) == NROW(filter(pExplored, qLLStab_sigAt>=0.01))

saveRDS(pExplored, 'pExplored.rds')

```

### Grid for plotting
Force the starting values to be a multiple of the step size. This avoids problems and is clear what the true parameter space is.

### Plots
True parameter vector $ \color{blue}{\theta} = `r thetaStar` $

#### Global search
Scatterplot for all searched values (useful for the global search)

##### S plot
```{r}
# INTERACTIVE PLOTs ----
#### S-plot ----
pSbase <- plot_ly(data = filter(pExplored, S<4.60517), 
                 x=~gammaF, 
                 y=~lambda,
                 color=) %>%
  layout(title = 'S-set for the New Keyneasian Phillips Curve (90% confidence)',
         xaxis = list(title=plotly::TeX('\\gamma_F'), 
                        tickvals=seq(from=0, to=1, by=0.10),
                        range = c(0, 1),
                        fixedrange = TRUE),
           yaxis = list(title=plotly::TeX('\\lambda'),  
                        tickvals=seq(from=0.001, to=0.2, by=0.05),
                        range = c(0.001, 0.2),
                        fixedrange = TRUE)) %>%
  add_trace(x = 0.591,y = 0.015,
    type = "scatter",   mode = "markers",
    marker = list(symbol = "square",  size = 12,  color = "red" ),
    inherit = FALSE,
    showlegend = FALSE) %>%
  config(mathjax = "cdn")

pSbase %>%
  add_trace(type='scatter', mode='markers', marker = list(color='blue'))

```

##### qLL-Stab plot
```{r}
# INTERACTIVE PLOTs ----
#### S-plot ----
pSbase <- plot_ly(data = filter(pExplored, qLLStab <= 18.14), 
                 x=~gammaF, 
                 y=~lambda,
                 color=) %>%
  layout(title = 'S-set for the New Keyneasian Phillips Curve (90% confidence)',
         xaxis = list(title=plotly::TeX('\\gamma_F'), 
                        tickvals=seq(from=0, to=1, by=0.10),
                        range = c(0, 1),
                        fixedrange = TRUE),
           yaxis = list(title=plotly::TeX('\\lambda'),  
                        tickvals=seq(from=0.001, to=0.2, by=0.05),
                        range = c(0.001, 0.2),
                        fixedrange = TRUE)) %>%
  config(mathjax = "cdn")

pSbase %>%
  add_trace(type='scatter', mode='markers')

```

```{r}
#### qLLStab plot ----
pQllExplored <- filter(pExplored, qLLStab_sigAt >= 0.1) %>%
  # Finding edges of the plot
  group_by(., gammaF) %>% 
  mutate('edge_min' = if_else(lambda == min(lambda), TRUE, FALSE),
         'edge_max' = if_else(lambda == max(lambda), TRUE, FALSE)) %>%
  ungroup()

pQllbase <- plot_ly(data = pQllExplored, 
                  x=~gammaF, y=~lambda, color=~qLLStab) %>%
  layout(title = 'qLL-S set for New Keyneasian Phillips Curve (90% confidence)',
         scene=list(
           xaxis = list(title=plotly::TeX('\\gamma_f'), 
                        tickvals=seq(from=PARAMS_CFG$minVal[1], to=PARAMS_CFG$maxVal[1],
                                     by=PARAMS_CFG$stepSize[1])),
           yaxis = list(title=plotly::TeX('\\lambda'),  
                        tickvals=seq(from=PARAMS_CFG$minVal[2],           to=PARAMS_CFG$maxVal[2], 
                                     by=PARAMS_CFG$stepSize[2])))) %>%
  config(mathjax = "cdn")

pQllbase %>%
  add_trace(type='scatter', mode='markers')

```

```{r}

pBase <- ggplot(data=pQllExplored, mapping=aes(x=gammaF, y=lambda)) +
  scale_x_continuous(name=TeX(r"(Respose to expected inflation ($\gamma_f$))"), limits=c(-0.1, 1.1), 
                     breaks=seq(from=-0.1, to=1.1, by=PARAMS_CFG$stepSize[1]), expand = expand_scale(mult=0.01)) +
  scale_y_continuous(name=TeX(r'(Respose to interest rate ($\lambda$))'), limits=c(-0.3, 0.3), 
                     breaks=seq(from=-0.3, to=0.3, by=4*(PARAMS_CFG$stepSize[2])), expand = expand_scale(mult=0.01)) + 
  theme_bw() + theme(panel.grid=element_line(colour='#999999', linetype='14'), 
                     panel.grid.minor=element_line(colour='white'), 
                     text=element_text(size=10), 
                     axis.title.x = element_text(colour='red'),
                     axis.title.y = element_text(colour='blue', size=rel(0.9), hjust=0.9),
                     axis.text.x = element_text(size=rel(1.25), angle=90, vjust=0.5), 
                     axis.text.y = element_text(size=rel(1.25))) +
  geom_vline(xintercept=0, colour = 'black', linetype = 'solid') +
  geom_hline(yintercept=0, colour = 'black', linetype = 'solid') +   
  # Highlightinh the TRUE value
  geom_point(aes(x=thetaStar['gammaF'], y=thetaStar['lambda']), size=3, colour='black', fill='yellow')

# Scatterplot
pBase + geom_point(aes(colour=qLLStab))
# Curvy set
pBase +
  coord_cartesian(xlim=c(-0.1, 1.1), ylim=c(-0.3, 0.3), expand=TRUE) + 
  geom_raster(fill='grey', colour='black',
            interpolate=TRUE, show.legend=TRUE, alpha=0.8) + 
  # Lower edge
  geom_path(data=filter(pQllExplored, edge_min == TRUE))  +
  # Upper edge
  geom_path(data=filter(pQllExplored, edge_max == TRUE))
# RA


```
