---
title: "Exploration - Hybrid NKPC"
author: "Emi"
date: today
date-meta: 08/06/2022
editor: 
  mode: source
format: 
  html:
    code-fold: true
    code-tools: true
    self-contained: true
    page-layout: full
    toc: true
params:
  OUTFOLDER: "/"
  LOCALSEARCH: FALSE
  NCORES: 8
  NSIPARAMS: 1 # number of estimated parameters under the null (nuisance parameters)
bibliography: [ref_iStabi_vignette.bib]
biblio-style: apalike
---

```{r, eval=FALSE}
#required packages to make a package
pacman::p_load(devtools, roxygen2, testthat)
#dependecies
#pacman::p_load(tidyverse, data.table, DT, plotly, gridExtra, latex2exp, here, logr, future.apply, furrr)
#pacman::p_load(dplyr,parallel,sandwich,here,future,logr,profvis,lobstr,parallel)
#https://ourcodingclub.github.io/tutorials/writing-r-package/
#create_package
#https://combine-australia.github.io/r-pkg-dev/functions.html
#load_all()
#run these two lines and then library(GridMaker) in normal rstudio to install package
# load_all loads a package. It roughly simulates what happens when a package is installed and loaded with library().
devtools::load_all()

devtools::install()

```

```{r}
library(GridMaker)
library(dplyr)
library(magrittr)
library(logr)
library(future) # this should be a dependancy of GridMaker
```

```{r}

# True values
thetaStar <- c('gammaF' = 0.591,
               'lambda' = 0.015,
               'gammaB' = 0.378)
```


```{=html}
.book .book-body .page-wrapper .page-inner {
  max-width: 1400px !important;
}
```

Inference on hybrid NKPC curve as in Mavroeidis (2005) `example_NKPC/sim`. See `sim_NKPC_M2005_GMMIV.html` for simulation details. 

Inference on the IV moment condition for the just-identified case.

## LOAD SIMULATED DATA
It can be $T=2000$ (2k) or $T=300$. There are 2,000 simulated models for each case.

```{r}
### LOAD DATA ----
# C:/Users/Emi/Box/UofA RESEARCH/iStabi/Examples/example_NKPC/
DATA <- GridMaker::sim_NKPC_sams300[[1]] %>%
  rename('s_t' = 's', 'pi_t' = 'pi') %>%
  mutate('t' = 1:NROW(.), .before=s_t)

# Build sample
ZLAGS = 2

breakDate = NROW(DATA)/2

Dlags <- tibble('s_tM1' = lag(DATA$s_t),
                'pi_tM1' = lag(DATA$pi_t),
                'pi_tP1' = lead(DATA$pi_t))
Dlags[, 'I_s_tM1'] <- c(rep(0, breakDate), Dlags$s_tM1[(breakDate+1):NROW(DATA)])

sel = c((ZLAGS+1):(NROW(DATA)-1))
sam <- cbind(DATA[sel, c('t', 's_t', 'pi_t')], Dlags[sel, ])

Z <- sam[, c('pi_tM1', 's_tM1', 'I_s_tM1')] %>%
  #cbind('Constant'=1, .) %>%
  as.matrix(.)

```

## THE MODEL

$$
\begin{align}
\pi_t &= \lambda s_t + \color{blue}{\gamma_f} \, \mathbb{E}[ \pi_{t+1} | \mathcal{I}_{t}] + \color{blue}{\gamma_b} \pi_{t-1} + \epsilon_{t} 
(\#eq:stcEqPi) \\
s_t &= \underbrace{0.9(1-\rho_2)}_{\rho_1} s_{t-1} + \rho_2 s_{t-2} + \upsilon_t
(\#eq:stcEqS)
\end{align}
$$

### The GMM equation
You replace $\mathbb{E}[y_{t+1}]$ by $\pi_{t+1}$ and the forecasting error, $\pi_{t+1}-\mathbb{E}[y_{t+1}]$ goes to the residual term in the estimating equation, $u_t \equiv \epsilon_t - \color{blue}{\gamma_f} (\pi_{t+1}-\mathbb{E}[y_{t+1}])$. 

### The moment condition

Then the moment equation is $Z' \times \bm{u}$ where $\mathbf{u}$ is the $T$ vector containing the residual from the above GMM equation, 
$$
u_t = y_t - \color{blue}{\lambda} s_t - \color{blue}{\gamma_f} \, y_{t+1} - \gamma_b \pi_{t-1}
$$
The parameter $\gamma_b$ is deemed to be strongly identified, it can be consistently estimated under the null by minimising the GMM function since $\pi_{t-1}$ is predetermined and unrelated to $u_t$.

Hence, we want to make inference on the structural parameter vector $\color{blue}{\theta} = \begin{bmatrix} \color{blue}{\lambda} & \color{blue}{\gamma_f} \end{bmatrix}$

The instruments are: $s_{t-1}$ and $\mathbb{I}_{t>`r NROW(DATA)/2`}(s_{t-1})$, where $\mathbb{I}$ is an indicator function which is 1 after the break ($t>`r NROW(DATA)/2`$) and 0 otherwise.  There is `1` moment equation, `2` instruments and `2` structural parameters. The model is just-identified.

The moment condition is:
$$
\begin{align}
\mathbb{E}[Z^{'} \, \mathbf{u}] &= 0 \\
\mathbb{E}\left[ Z^{'} \, (Y \mathbf{b(\color{blue}{\theta})} - X c) \right] &= 0
\end{align}
$$
 where $\mathbf{u}$ is a $(T \times 1)$ vector of residuals and
$$
Z =
\begin{bmatrix}
  \pi_{1}   &   s_{1} & \mathbb{I}(s_{1}) \\ 
  \pi_{2}   &   s_{2} & \mathbb{I}(s_{2}) \\
  \pi_{3}   &   s_{3} & \mathbb{I}(s_{3}) \\
  \vdots    &   \vdots & \vdots  \\
  \pi_{T-1}   &   s_{T-1} & \mathbb{I}(x_{T-1}) 
\end{bmatrix}_{(T-1) \times K}
$$

Notice the first-stage regression includes all variables in the second-stage (structural) regression. In other terms, All variables in equation \@ref(eq:stcEqPi) are instrumented, $\pi_{t-1}$ is instrumented by itself. 

```{r}
Z <- sam[c('pi_tM1', 's_tM1', 'I_s_tM1')] %>%
     #cbind('Constant'=1, .) %>%
      as.matrix(.)
```

Futhermore, the residual vector is computed as $\mathbf{u} = Y \mathbf{b(\color{blue}{\theta})} - X \mathbf{c}$ with,
$$
\begin{align}
Y = 
\begin{bmatrix}
  \pi_1        &   s_{1}  &   \pi_{2}  \\
  \pi_2        &   s_{2}  &   \pi_{3}  \\
  \vdots       &   \vdots  &   \vdots   \\
  \pi_{T-1}    &   s_{T-1} &   \pi_{T}  \\ 
\end{bmatrix}_{(T \times 3)},  &
\; \text{ and } b(\color{blue}{\theta}) = 
  \begin{bmatrix}
  1   &   -\color{blue}{\lambda} & -\color{blue}{\gamma_f} \\
  \end{bmatrix}.
\end{align}
$$


```{r}
NEQS = 1
# Yb
# Get the vector b
GET_B <- function(theta0) {
  c(1, 
    -theta0['lambda'],
    -theta0['gammaF'])
}
# Y = [y_t s_t y_t+1]
Y <- cbind( 'pi_t' = sam$pi_t, 's_t' = sam$s_t, 'pi_tP1' = sam$pi_tP1 )
#rm(X)
```

Finally, the $X$ matrix relates to the parameter that is considered to be strongly identified, $\kappa$ which is a constant. $X$ is then a constant vector.
```{r}
X <- sam['pi_tM1'] %>% as.matrix(.)
```

#### Conditions for identification
There are 2 structural parameters, 1 moment equation and 2 instruments ($s_{t-1},  \mathbb{I} s_{t-1}$), hence 2 moment conditions. The system of equations is just-identified.

## SEARCH

### Gradient and exact solution
The GMM minimand is 
$$
Q_{T}(\mathbf{\theta})=\mathbf{f}(\mathbf{\theta})^{\top} \: W_{T} \: \mathbf{f}(\mathbf{\theta})
$$
The gradient $(1 \times p)$ gradient $G(\mathbf{\theta})$ (Jacobian) is:
$$ \underbrace{\nabla = G(\mathbf{\theta})  =  \frac{\partial Q}{\partial \mathbf{\theta}}}_{(1 \times p)} = 2 \mathbf{f}^{\top} \: W  \: \underbrace{ \frac{\partial \mathbf{f}}{\partial \mathbf{\theta}} }_{(K_z+K_x \times p)} $$
with 
$$ 
\frac{\partial \mathbf{f}}{\partial \mathbf{\theta}} = T^{-1} Z^{\top} Y
\begin{bmatrix}
0 & 0 \\
-1 & 0 \\
0 & -1
\end{bmatrix}
$$
Notice that:
$$ 
\begin{align}
\frac{\partial \mathbf{f}}{\partial \mathbf{\theta}}=
\begin{bmatrix}
\frac{\partial f_{1}}{\partial \lambda} & \frac{\partial f_{1}}{\partial \gamma_f} \\
\frac{\partial f_{2}}{\partial \lambda} & \frac{\partial f_{2}}{\partial \gamma_f} \\
\frac{\partial f_{3}}{\partial \lambda} & \frac{\partial f_{3}}{\partial \gamma_f}
\end{bmatrix} &
\text{ with } \mathbf{\theta} = 
\left[ \begin{smallmatrix}
\lambda  & \gamma_f
\end{smallmatrix} \right]
\end{align}
$$


```{r}
get_deriv_B <- function(theta0) {
  
  rbind(c(0, 0),
  c(-1, 0),
  c(0, -1))
  
}
```

For the **exact solution** I use the standard GMM-IV which is easier to compute. 
The IV problem is
$$
\begin{align}
\mathbf{y} &= X \mathbf{\theta} + \mathbf{u} \\
X &= Z \mathbf{\Pi} + \mathbf{\epsilon}
\end{align}
$$

In our case we have $(\mathbf{y}, X, Z)$, where $\mathbf{y}$ is the dependant variable ($\pi_t$), $X$ are all variables in the structural model, $\pi_{t+1}, s_t, \pi_{t-1}$, (2 endogenous and an exogenous one that will be instrumented by itself. The parameter vector $\mathbf{\theta} = \left[ \gamma_f, \lambda, \gamma_b \right]$. Finally $Z$ contains all instruments, $s_{t-1}, \mathbb{I}s_{t-1}, \pi_{t-1}$. 

We define the objects in R:
```{r}
# Data for closed-form solution in the Standard IV objects
# The nuisance variable is the LAST one.
stdIVobjs <- list('y' = {sam['pi_t'] %>% as.matrix()},
            'X' = { sam[c('s_t' , 'pi_tP1', 'pi_tM1')] %>% as.matrix()},
            'Z' = { sam[c('s_tM1', 'I_s_tM1', 'pi_tM1')] %>% as.matrix()})
```

The solution is:
$$
\begin{equation}
\hat{\theta_{T}} = 
\left\{ \left(\frac{1}{T}\right)^{2}  (  X^{\top} Z)\,  W_T\, ( Z^{\top} X ) \right\}^{-1}
\:\: \left(\frac{1}{T}\right)^{2} (X^{\top} Z)\,  W_T \, ( Z^{\top}) \, \color{red}{\mathbf{y}}
\end{equation}
$$
For the first-step, $\hat{ {\theta_{T}}^{(1)}}$,  we can consider $W_T = Z Z^{\top}$ and then notice above that $Z W_T Z^{\top} = P_{Z}$ where $P_{Z}$ is the projection matrix, thus
$$
\begin{equation}
\hat{ {\theta_{T}}^{(1)}} = 
\left\{ \left(\frac{1}{T}\right)^{2}  (  X^{\top} P_{Z} X ) \right\}^{-1}
\:\: \left(\frac{1}{T}\right)^{2} (X^{\top} P_Z ) \, \color{red}{\mathbf{y}}
\end{equation}
$$
FOr the second step $\hat{ {\theta_{T}}^{(2)}}$, $W_T$ is the inverse of a HAC estimator of the variance of $f_{t}(\mathbf{\theta})$. 
$$
\begin{equation}
\hat{\theta_{T}} = 
\left\{ \left(\frac{1}{T}\right)^{2}  (  X^{\top} Z)\,  W_T\, ( Z^{\top} X ) \right\}^{-1}
\:\: \left(\frac{1}{T}\right)^{2} (X^{\top} Z)\,  W_T \, ( Z^{\top}) \, \color{red}{\mathbf{y}}
\end{equation}
$$
where $W_T = \hat{S^{-1}}$ where $S = \mathbb{V}ar(f_{t})$.

### Descriptive statistics
```{r}
t(apply(cbind(Y,Z), 2, FUN = function(aCol) c('mean'=mean(aCol), 'sd'=sd(aCol), 'min'=min(aCol), 'max'=max(aCol))))
```


### Search settings
Define some parameter for the search and build necesary objects that I want them to be in the top environment since they will be used by many functions.

```{r}
#### Search settings ----
NCORES = params$NCORES
STEPSPERCORE = 200
# Size of adjacent cells to explores is NCORES * STEPSPERCORE

# PARAMS_CFG a tibble where each row defines properties of the parameters in the name column
# stepSize: size of the step for each parameter. You can have different sizes (and precision) for each paramter.
# minVal and maxVal: Limits of the parameter space for each parameters. A list where each element defines the minimum and maximum for each parameter
# ORDER: the order of the parameter has to match the order in theta (as used by the get_b() fcn)
PARAMS_CFG <- tribble(~name,   ~iniVal, ~stepSize, ~minVal, ~maxVal,
                      'lambda', NA,    0.003,        0,      0.2,
                       'gammaF',  NA,   0.02,        0,       1) %>%
  mutate('N_TICKS' = ((maxVal-minVal)/stepSize)+1)

# Initial value
PARAMS_CFG$iniVal <- sam %>%
  lm(pi_t ~ 1 + s_t  + pi_tP1  + pi_tM1, data=.) %>%
  .$coefficients %>%
  {c('lambda' = .[['s_t']],
     'gammaF' = .[['pi_tP1']])}


```

```{r}
NEQS = 1
MODELEQS <- list(list('Y' = Y,  'get_b'=NULL, 'X'=X, 'Z'=Z))
# Level of condfidence of the S set. The closer to 1, the more robust the search is to local minima but it takes longer.
SPVALUE = 0.95
# R is NEQS*ncol(Z) where ncol(Z) is the number of instruments
# By default this matrix has to be automatically built depending on the dimensions of MODELEQS.
# The user can alternatively provide this matrix
R <-    rbind(
  cbind(matrix(1, nrow=ncol(Z), ncol=ncol(Z)))
)
```

```{r}
verify_global(PARAMS_CFG, Y, Z)
Times = NROW(sam) # time periods
generate_global(PARAMS_CFG,  Z, X, SPVALUE)
```


Start the search!

### Global search grid

```{r}
gridLines <- build_lines(PARAMS_CFG, 'iniVal')

# paramsCfg <- PARAMS_CFG
# thisGridLines <- thisGridLines
# NEQS = 1
# psUnderNull = 1
Grid <- build_grid(PARAMS_CFG, gridLines)
```

```{r}
theta0 = c('lambda' = 0.015, 'gammaF' = 0.591) # the true theta with the estimated (nuisance) parameter 0.378
comp_tests(theta0, VffLags = NULL)
```

```{r}
# this should go into the packge
NPARAMS = NROW(filter(PARAMS_CFG, N_TICKS>0))

  
```

#### Search this!

```{r, search}

logFileName <- 'log_file.txt'
log_open(logFileName, logdir=FALSE, compact=TRUE)
log_print(paste0("Local search? ", params$LOCALSEARCH))

#log_print(paste0("IniRows size (in bytes): ", lobstr::obj_size(IniRows)))
# rover_Perseverance will update the Grid in the Global env
plan(multisession, workers=params$NCORES)

log_print("Calling garbage collector before Stage2_rover_Perseverance")
gc() %>% log_print()
  
expResult <- Stage2_rover_Perseverance(iniVal=PARAMS_CFG$iniVal, WTLags = 1, localSearch = FALSE) # updates the Grid by in place
# Compute the genS test
Grid[, genS_qLL := (qLLStab + (10/11)*S)]

#saveRDS(Explored, file=paste0(params$OUTFOLDER, 'Explored.rds'))
saveRDS(list('PARAMS_CFG' = PARAMS_CFG, 'gridLines' = gridLines,  'KZMKX' = KZMKX, 'NSIPARAMS' = params$NSIPARAMS,
             'Explored' = Grid, 'expResult' = expResult), 
        file='Results.rds')
```

<!-- TODO -->

<!-- 
### Local search grid


```{r, cache=FALSE, eval=FALSE}
# Find minimum and rotate initial value if needed it
# Standard IV objects
# Minimums S fcn (GMM minimand)
minsS <- list('Closed' = list(),
              'NelderMead' = list(),
              'LBFGSB' = list())
# 2-step GMM closed-form solution
minsS$Closed <- first_Stage(method='Closed', SIV=stdIVobjs)
minsS$NelderMead <- first_Stage(method='NelderMead')
minsS$LBFGSB <- first_Stage(method='LBFGSB', gr_T = comp_grad)


fstRes <- map2_dfr(minsS, names(minsS), 
                   function(minS, methodName) {
  #browser()
  list2env(minS, envir=environment())
  tibble('method' = methodName, 
         'lambda' = par['lambda'],
         'gammaF' = par['gammaF'],
         'value' = value,
         'convergence' = convergence,
         'tSeconds' = tSeconds,
         'counts.function' = counts['function'],
         'counts.gradient' = counts['gradient'],
         'message' = message)
})

fstRes %>% 
        DT::datatable(filter='top',
                      options=list('scrollX'=TRUE))


```

End first stage.


#### Stage 2: explore around minimums

```{r, cache=TRUE, eval=FALSE}
tictoc::tic()
##profvis()
## EXPlored SET

# Combine minimas
iniThetas <- map_dfr(minsS, function(aMin) {
              aMin$par
              }) %>%
              round(., digits=3)

Explored <- rover_Perseverance(iniThetas, get_b,
           VffLAGS = 1)
  
saveRDS(Explored, file=paste0(OUTFOLDER, 'Explored.rds'))
tictoc::toc()
```

End second stage.

-->

